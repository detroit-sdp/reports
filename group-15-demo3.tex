%% Template for SDP report, adapted from mlp_cw2_template, 2018. 

%% Based on  LaTeX template for ICML 2017 - example_paper.tex at 
%%  https://2017.icml.cc/Conferences/2017/StyleAuthorInstructions

\documentclass{article}
\input{mlp2018_includes}

%% You probably do not need to change anything above this comment

%% REPLACE the details in the following commands with your details
\setGroupNumber{15}
\setGroupName{Detroit}
\setProductName{Tadashi}
\setDemoNumber{3}
\setLogoFileName{figs/logo-small.png}

\begin{document} 

\makeSDPTitle{Demo}

% Previous MLP Style Title Layout working. 
% \twocolumn[
    % \mlptitle{\productName: SDP Demo \demoNumber}
    % \centerline{Group \groupNumber: \groupName}
% ]

\begin{abstract}
  Tadashi is an assistive robot for delivering food and water to residents in supported living and care home environments.
  In this demo, we demonstrate significant progress towards a minimum viable product (MVP). We integrate components of our system together, demonstrating a full use-case: the caregiver placing a delivery on the tray and scheduling the robot to visit a room; the robot navigating to the room; the lift extending on arrival and detecting that the resident has picked up the delivery using integrated weight sensors; the lift retracting once the delivery has been made, and the robot sending a message to the app to indicate this; and the robot returning to its starting point. We also discuss usability testing we have performed on our app to ensure it is usable by non-technical caregivers, and discuss future improvements to the app based on this. 
\end{abstract} 

\section{Project plan update} 
\begin{itemize}
\item Begin testing app with non-technical users to gain insights on accessibility and ease of use: {\bf achieved}.
\item Make changes to app justified against results of testing: {\bf partially achieved}.
\item Complete user interviews with caregivers to assess demand for project features and implement new features based on caregiver requests: {\bf not achieved}.
\item Physically integrate lift mechanism into robot body, and integrate lift control into robot control software: {\bf partially achieved}.
\item Design and manufacture a tray to place on top of the lift to hold items: {\bf achieved}.
\item Add sensor to lift to determine whether items have been removed: {\bf achieved}.
\item Refine robot problem-solving when stuck by tuning mapping sensitivity and obstacle avoidance logic: {\bf partially achieved}. 
\item Implement bi-directional communication between the app and robot: {\bf achieved}.
\end{itemize}

We were not able to complete user interviews due to delays in receiving ethical approval (due to strike action). We intend to complete these as soon as we receive the approval. We were able to fully mount the lift onto the Turtlebot and partially able to implement communication between the robot and the lift, but the last part of this was scheduled for Saturday and therefore not completed due to the team having to move to remote work. Likewise, we were able to tune the robot's movement parameters, but we were not able to fully test this because of the team moving to remote work. 

\begin{table}[]
  \begin{tabular}{l|l}
    Task & Members \\
    \hline
    Robot refinements & Ben, Wojtek \\
    App refinements & Ching Ling, Yuchen \\
    Project management & Michael \\
    User testing & Theo \\
    Product development & Rebecca \\
    Lift building and mounting & Luukas \\
    Lift-robot connection & Errikos, Luukas, Jakub \\
    App-robot connection & Ben, Yuchen \\
  \end{tabular}
  \caption{Task splits across the group up to demo \demoNumber. Core teams and points of contact remain the same as with demo 2, but tasks were done by combining expertise across teams. }
  \label{tab:group-split}
\end{table}

We began the sprint with teams working the same as for demo 2 in order to refine individual components: refining robot problem-solving logic and movement parameters, refining the app, and finalizing the design and physical mounting of the lift. We then began focusing on the connections between aspects of our project. To do this, ad-hoc teams were created based on the knowledge each person had of the system they worked on, as seen in table \ref{tab:group-split}. To ensure effective collaboration, these teams met and worked in person, doing pair-programming to ensure expertise could be effectively utilised and to reduce the need to spend time integrating or merging code. As with previous sprints, code was tracked using GitHub for version control, and group communication was done through Slack and once-weekly meetings.

Our total budget spending so far consists of:
\begin{itemize}
  \item \pounds 0 ({\bf TODO update}) on non-budgeted monetary costs, ie. items taken from the starting kit and therefore not deducted from total budget;
  \item \pounds 30.80 on budgeted monetary costs to improve the lift, leaving us with \pounds 147.61 in our monetary budget; 
  \item 3 hours of technician time to mount the lift, leaving us with 1.25 hours technician time remaining. 
\end{itemize}

Owing to the ongoing coronavirus situation, the entire team began working remotely from Saturday 14th March. This means we need to halt work on the robot and the lift, as we cannot access or run these remotely. Decisions are still ongoing as to how to continue work in this situation, so our goals may change as the situation develops. Currently, we aim to do the following for demo 4:
\begin{itemize}
  \item Complete user interviews, analyse results, and implement changes to our product to match user demand.
  \item Improve app based on usability testing, and perform another round of usability tests to assess if changes have made a difference to usability. 
  \item Explore other technical additions to the product to ensure our technical time is spent in a way that adds value to the product. 
\end{itemize}

\section{Technical details}
\subsection{Connectivity}
\begin{figure}
  \begin{center}
    \includegraphics[width=\columnwidth]{figs/connectivity.pdf}
  \end{center}
  \caption{The connections between each aspect of our product, showing what messages are sent during the use-case.}
\end{figure}
\subsection{Hardware}
\begin{figure}
  \begin{center}
    \includegraphics[width=\columnwidth]{figs/weight_sensor.jpg}
    \caption{The top of the lift, showing the manufactured tray with the Tadashi logo and weight sensor underneath.}
  \label{fig:sensor}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \includegraphics[width=\columnwidth]{figs/lift_view.jpg}
    \caption{Side view of the lift mounted to the Turtlebot. Points to note include the metal brackets used to fix the lift in place; the removal of the EV3 brick and addition of the Arduino kit and batteries; and the tray placed on top.}
  \label{fig:lift}
  \end{center}
\end{figure}

% \begin{figure}
%   \begin{center}
%     \includegraphics[width=\columnwidth]{figs/lift_detail.jpg}
%     \caption{Inside view of lift mechanics. Note that the motors and sensors are now controlled by an Arduino to better allow for communication with the robot. }
%   \label{fig:arduino}
%   \end{center}
% \end{figure}

\subsection{User interface}

\subsection{Software}

From its state in the previous demo, the robot software has moved towards what would have been our envisaged final product. In summary, it has evolved in the following key ways:

\begin{itemize}
  \item The robot now keeps track of a variety of variables regarding its state
  \item The robot now calculates a vector to its intended destination from its current position
  \item The parameters powering the robots autonomous navigation have been configured in order to suit our configuration more appropriately
  \item The robot can now control the lift directly through a serial connection between the Raspberry Pi board and the arduino controlling the lift
  \item The ROS node controlling the navigation stack and networking is now able to communicate with the app bidirectionally
\end{itemize}

%Item 1
For obvious reasons, we wanted the app to be able to access certain information about the current state of our robot. The information we decided would be particularly important is the state of its battery, as well as its current 'behaviour' in the world. These different status' are stored in a dictionary. We decided to use a dictionary over a list so that we could assign our own code to each state. This would be useful later on if we were to implement some kind of error recognition i.e. {\it def a} should not run if the state is less than 0. We note that in the average case, item retreival is O(1) in both lists and dictionaries and so there was no obvious reason against using a dictionary here given this is all we use this particular one for. The states we had included at this stage were: low battery, assistance required, at base \& not busy, moving, and arrived at goal.

% Item 2
At any given moment the robot knows both its own position (with respect to where it was booted up) and the map (again, placing itself in the origin on startup). The starting position can be altered. However, we decided to map our space beginning at the 'base' meaning that this is the origin on our map. Every time we start up the robot it is started in this position. In the real world, the base would be the area where the robot is loaded and charged.

The navigation stack takes a goal in and calculates the path to this goal. The goal is not a set of coordinates in the map, but a pair of distances on the x and y axes and a rotation at this goal. If you were to always start at the same location facing the same direction, this would function the same as if you were to give it a set of coordinates. The problem is that you are not always moving from the same base due to goal tolerance allowing for some specified inaccuracy in order to save time, as well as natural drift. In order to correct this, we decided to have our robot take in the coordinates of the goal and calculate the vector from its current position.

As a further complication, the robot always believes that it is facing forwards. That is, while you can specify a rotational move using a quaternion (x,y,z,w), the robot will always think of its own rotation as being forward or (0,0,0,1). This means that the axes rotate with the robot in its own mind. Due to the obvious difficulties this presents when calculating our way back to base, we decided to restrict the robot to a four-directional goal system - forwards, backwards, right, and left with each having its own quaternion move (Table~\ref{tab:quaternions}).

With all this in mind, we store our room coordinates in another dictionary in Python. For this dictionary, lookup is also important in order to verify if the target room exists. Lookup, insertion, and deletion are O(n) in the average case for lists, but are O(1) for dictionaries. This is not to mention that fact that it allows us to index the rooms however we please. Each entry in the dictionary stores the coordinates of the room, and the targeted rotation at this goal (L,B,F, or R).

Based on observation, we believe that using the coordinates-vector system is unsurprisingly more accurate over time than using distances as before. Due to the team not feeling comfortable returning to Appleton Tower in the wake of the global COVID-19 pandemic, we were not able to carry out official tests on this. Our test plans are detailed in Evaluation section of this report.

\begin{table}[h]
\vskip 3mm
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccc}
\hline
\abovespace\belowspace
Direction & x & y & z & w \\
\hline
  Forward & 0 & 0 & 0 & 1\\
  Backwards & 0 & 0 & 1 & 0 \\
  Right & 0 & 0 & -0.7071 & 0.7071 \\
  Left & 0 & 0 & 0.7071 & 0.7071 
\end{tabular}
\end{sc}
\end{small}
\caption{Quaternion movement inputs for each direction.}
\label{tab:quaternions}
\end{center}
\vskip -3mm
\end{table}

% Item 3
After we located the parameter files for the navigation stack, we altered them to suit our configuration more appropriately. We found a parameter under the robots description of itself that it provides to the stack named <collision>...</collision>. We believe the stack uses this in order to avoid collision between the robot and the surrounding world. Furthermore, this tag features an attribute <box size> which was set on default to values very closely resembling the dimensions of the Turtlebot. We altered this to match the new dimensions of our bot. Specfically, the length of our bot is approximately 40.0cm as opposed to the original 28.1cm. Unfortunately, this is something that is incredibly difficult to test due to the robot avoiding obstacles very conservatively as a result of other parameter changes below, but we did not encounter any problems in our test runs where we have at previous points in development.

The other key parameters are mostly self-explanatory other than the following. [min/max]\_trans\_vel is the speed of the robot when moving in a straight line. path\_distance\_bias determines how closely the robot need follow the path it works out. Given our robot always calculated an accurate path, we increased this value. goal\_distance\_bias smoothes the trajectory of the path and makes it more efficient. Again, we decided to increase this. Finally, occdist\_scale determines how 'afraid' the robot is of obstacles. We lowered this to make it behave a little safer due to our length alteration. All our parameter changes are detailed in table~\ref{tab:params}. Much like the coordinate system, initial observation would suggest to us that our parameters are more suitable with official testing on the speed and accuracy unable to be carried out.

\begin{table}[h]
\vskip 3mm
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcc}
\hline
\abovespace\belowspace
Parameters & Original value & Our value \\
\hline
  max\_vel\_x & 0.26 & 0.1 \\
  min\_vel\_x & -0.26 & -0.1 \\
  max\_trans\_vel & 0.26 & 0.1 \\
  min\_trans\_vel & 0.13 & 0.07 \\
  max\_rot\_vel & 1.82 & 1.3 \\
  xy\_goal\_tolerance & 0.05 & 0.175 \\
  path\_distance\_bias & 32.0 & 65.0 \\
  goal\_distance\_bias & 20.0 & 40.0 \\
  occdist\_scale & 0.02 & 0.01
\end{tabular}
\end{sc}
\end{small}
\caption{Our parameter alterations.}
\label{tab:params}
\end{center}
\vskip -3mm
\end{table}

% Item 4
In order to achieve our future goal of the robot controlling the lift uppon arrival, we had to establish a connection between the Raspberry Pi and the Arduino (lift controller). We reviewed multiple options including a variety of wireless methodologies (Bluetooth, WiFi etc), but decided in the end that the fastest and most reliable method would be to use a serial connection between USB ports on each board.

The Arduino already possessed the code to operate the lift, so it was a case of writing a Python script that could read/write bytes of data over the connection. The Raspberry Pi sends a single byte to the Arduino with possible values from 0-3 indicating stop, extend lift, and retract lift respectively. The Arduino returns the status of the lift as well as the current readings from the two weight sensors.

The connection was initially unreliable due to synchronization issues. After they were resolved the bytes were successfully transmitted every time.

% Item 5
Most of the work in terms of getting the bidirectional connectivity established with the app was done on the app side. Once they were able to forward packets from the host machine to the emulator, our job was to handle the sending of UDP packets to the app when appropriate. We discussed why UDP was used in previous demos and reports, but briefly, it was because there was no need for a formal connection to be held between the app and the robot. Due to the fact we were sending a single packet at any given time, packet loss is also a non-issue for our system. The system returns a packet to the app whenever the state changes. The packet simply contains one of the messages listed above and any logic for the handling of them happens on the app side. As mentioned in previous reports, we had to route the packets through the Turtlebot due to - what we believe to be - dynamic NAT being disabled on the sdp-robots router.

The future of the coding team remains uncertain due to the crisis we face at the moment. However, we planned to next implement the Raspberry Pi inspecting packets for the {\bf STATUS ARRIVED} packet, and controlling the lift based on this. We also planned to have the robot retract the lift when items had been removed from the tray and return to the base on doing this. Finally, we planned to do testing for this demo as well as on our future plans followed by a general polishing of the product for industry day.

\subsection{Business development}

\section{Evaluation}

\section{Budget}
As with the previous demo, the bulk of our costs are associated with building, mounting, and integrating the lift. Tables \ref{tab:non-budget-cost}-\ref{tab:budget-cost-non-monetary} show spending to date including spending at previous demos. Equipment costs are based on values provided in the SDP wiki \cite{sdpcosts}.

\begin{table}[h]
\begin{center}
    \resizebox{\columnwidth}{!}{
  \begin{tabular}{lllll}
    {\bf Item} & {\bf Units} & {\bf Cost (\pounds\ per unit)} & {\bf Total cost (\pounds)} & {\bf Use} \\
    \hline
    Turtlebot Waffle & 1 & 1275.80 & 1275.80 & Robot \\
    Lego & 2.5kg & 15.00 & 37.50 & Lift \\
    Arduino kit & 1 & 60.00 & 60.00 & Lift \\
    \hline \hline
               &       & Overall cost (\pounds) & 1373.3
  \end{tabular}}
\caption{Non-budgeted monetary costs at demo \demoNumber. Note that we have chosen to stop using the EV3 and instead use the Arduino kit.}
\label{tab:non-budget-cost}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
  \resizebox{\columnwidth}{!}{
  \begin{tabular}{lllll}
    {\bf Item} & {\bf Total cost (\pounds)} & {\bf Use} \\
    \hline
    Turtlebot supports  & 8.00 & Lift \\
    MDF support (12mm x 270mm x 400mm) & 1.00  & Lift \\ 
    Lift support rods & 5.00 & Lift \\
    Pegboard ($0.62 \text{m}^2$ at \pounds 12 per $2.88 \text{m}^2$)& 2.59 & Arena \\
    Misc (wires, screws, angle brackets) & 10.00 & Lift, arena \\
    MDF support (6 x 350  x 230mm) & 0.30 & Lift \\
    MDF support (9 x 70 x 230mm, 9 x 10 x 250mm (2x)) & 0.10 & Lift \\
    Engraved tray & 5.80 & Lift \\
    Weight sensors (2x) & 19.60 & Lift \\
    \hline
    \hline
     Budget spent (\pounds) & 52.39 \\
     Budget remaining (\pounds) & 147.61
  \end{tabular}}
\caption{Budgeted monetary costs at demo \demoNumber. MDF value is approximate as 12mm MDF is not on the SDP price sheet.}
\label{tab:budget-cost-monetary}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
  \resizebox{\columnwidth}{!}{
  \begin{tabular}{lll}
    {\bf Purpose} & {\bf Hours spent} & {\bf Use} \\
    \hline
    Manufacturing lift support rods & 1 & Lift \\
    Manufacturing lift base (MDF) & 0.5 & Lift \\
    Drilling holes in lift base & 0.25 & Lift \\
    Engraving tray & 1 & Lift \\
    Attaching lift to base & 1 & Lift \\
    Cutting MDF to mount lift to base & 1 & Lift \\
    \hline
    \hline
    Overall technician hours spent & 4.75 & \\
    Total technician hours remaining & 1.25
  \end{tabular}}
\caption{Budgeted technician time at demo \demoNumber. Note that hours remaining includes subtracting any hours lost due to not being used in previous weeks.}
\label{tab:budget-cost-non-monetary}
\end{center}
\end{table}


%% Include any references in a bibliography

\bibliography{demo1-refs}

\end{document} 

